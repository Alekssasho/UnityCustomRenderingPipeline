
#include "../ShaderLibrary/Common.hlsl"
#include "../ShaderLibrary/CommonPathTracing.hlsl"

RWTexture2D<float4> RenderTarget;

#pragma max_recursion_depth 1

float g_AspectRatio;
RaytracingAccelerationStructure g_AccelStructure;

struct Light {
    enum Type : uint {
        Directional,
    };

    float3 color;
    float3 direction;
    float3 position;
    Type type;
};

StructuredBuffer<Light> g_Lights;

[shader("raygeneration")]
void MyRaygenShader()
{
    uint2 launchIdx = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    float2 ndcCoords = (launchIdx / float2(launchDim.x - 1, launchDim.y - 1)) * 2 - float2(1, 1);
    float t = unity_CameraProjection._m11;
    const float Rad2Deg = 180 / 3.141592653;
    float fov = atan(1.0f / t) * 2.0 * Rad2Deg;
    ndcCoords *= tan(fov / 2 * 3.141592653 / 180);
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio, ndcCoords.y, 1));
    RayDesc ray;
    ray.Origin = _WorldSpaceCameraPos;
    ray.Direction = mul((float3x3)unity_CameraToWorld, viewDirection);
    ray.TMin = 0;
    ray.TMax = 1e20f;

    PathTracingRayPayload payload;

    TraceRay(g_AccelStructure, 0, 0xFF, 0, 1, 0, ray, payload);

    float3 colorToWrite = 0.0;
    if (payload.hitType == HitType::LitSurface)
    {
        // TODO: choose better light
        uint choosenLightIndex = 0;

        Light light = g_Lights[0];

        colorToWrite = payload.color
            * saturate(dot(payload.normal, -light.direction))
            * light.color;
    }
    else if (payload.hitType == HitType::Environment)
    {
        colorToWrite = payload.color;
    }
   
    RenderTarget[launchIdx] = colorToWrite.xyzz;
}

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"

TextureCube<float4> unity_SpecCube0;
SAMPLER(samplerunity_SpecCube0);

[shader("miss")]
void MissShader(inout PathTracingRayPayload payload : SV_RayPayload)
{
    float4 environment = SAMPLE_TEXTURECUBE_LOD(
        unity_SpecCube0, samplerunity_SpecCube0, WorldRayDirection(), 0);
    //environment.xyz = DecodeHDREnvironment(environment, unity_SpecCube0_HDR);
    payload.color = environment.xyz;
    payload.hitType = HitType::Environment;
}
